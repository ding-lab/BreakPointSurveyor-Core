# Matthew Wyczalkowski
# m.wyczalkowski@wustl.edu
# The Genome Institute

#
# Usage: Rscript BreakPointProcessor.R [-v] [-o SBP.dat] pSBP.dat 
# Version 1.7 5/12/15 - adds contig.id 
# Version 1.6 5/12/15 - accounts for forward, reverse sequences.  
# Version 1.5 5/4/15 - add support for multiple breakpoints per contig
# Version 1.0 5/3/15

# Aim is to join per-sam-line pSBP input data generated by SAMReader.py to output SBP file
# with base-pair-level resolution of a breakpoint created by a pair of chimeric segments

# For a contig with multiple alignments, one will be primary (is_primary flag set, i.e., 0x800 unset).
# All segments will have either a forward or backward direction depending on if their is_reverse flag is the
# same as the is_reverse flag of the primary segment or the opposite, respectively.
# backward segments have their SEQ reverse complemented with respect to the primary segment, and the logic
# of their start, end sequence positions swapped.  Left, right positions are start, end positions swapped as
# appropriate.

# output file format:  
#     1  query_name  8^128865748^gi|9626069|ref|NC_001357.1|^2902^CTX^143^-+.Contig-15.-1.-9.7.3.2.11.10.4.8.6.5.14.16
#     2  contig.id   1
#     3  bp.id   1
#     4  ref_name.Sa gi|9626069|ref|NC_001357.1|
#     5  is_primary.Sa   FALSE
#     6  is_forward.Sa   FALSE
#     7  left_gpos.Sa    1
#     8  right_gpos.Sa   430
#     9  left_rpos.Sa    3308
#    10  right_rpos.Sa   2879
#    11  ref_name.Sb 8
#    12  is_primary.Sb   TRUE
#    13  is_forward.Sb   TRUE
#    14  left_gpos.Sb    441
#    15  right_gpos.Sb   1316
#    16  left_rpos.Sb    128865729
#    17  right_rpos.Sb   128866602
#
# Sa and Sb refer to left, right aligned segments from bwa-mem alignment.  In case of multiple (N) aligned segments
# for a contig, (N-1) breakpoints

#library("reshape2")
library("plyr")
#library("RColorBrewer")
options("width"=300) # useful for debugging

get_val_arg = function(args, flag, default) {
    ix = pmatch(flag, args)
    if (!is.na(ix)){ val = args[ix+1] } else { val = default }
    return(val)
}

get_bool_arg = function(args, flag) {
    ix = pmatch(flag, args)
    if (!is.na(ix)){ val = TRUE } else { val = FALSE }
    return(val)
}

parse_args = function() {
    args = commandArgs(trailingOnly = TRUE)

    # optional arguments
    verbose = get_bool_arg(args, "-v")
    SBP.fn = get_val_arg(args, "-o", "")  # "" will write to stdout

    # mandatory positional arguments.  These are popped off the back of the array, last one listed first.
    pSBP.fn = args[length(args)];               args = args[-length(args)]
    SBP.fn = args[length(args)]; args = args[-length(args)]

    val = list( 'verbose'=verbose, 'pSBP.fn'=pSBP.fn, 'SBP.fn'=SBP.fn )
    
    if (val$verbose) { print(val) }
    return (val)
}

reorder.by.seq = function(pSBP) {
    # use midpoint of sequence position to determine segment order and breakpoint pairs
    pSBP$mid_gpos = pSBP$left_gpos + (pSBP$right_gpos - pSBP$left_gpos) / 2
    # order by query_name first, then by mid_gpos
    pSBP = pSBP[with(pSBP, order(query_name, mid_gpos)), ]
    return(pSBP)
}

# read in pSBP file and obtain sequence midpoint position.  Order segments by contig name and midpoint position.
read.pSBP = function(pSBP.fn) {
    # Read in csv file
    pSBP = unique(read.table(pSBP.fn, row.names=NULL, header=TRUE, sep = "\t"))
    pSBP$is_reverse = as.logical(pSBP$is_reverse)
    pSBP$is_primary = as.logical(pSBP$is_primary)

    return(pSBP)
}


# Define global sequence position (gpos)
define.left.right.pos = function(pSBP) {
    pSBP$left_gpos = 0
    pSBP$right_gpos = 0
    pSBP$left_rpos = 0
    pSBP$right_rpos = 0

    forward.segments = which(pSBP$is_forward)
    reverse.segments = which(!pSBP$is_forward)
    if (length(forward.segments) > 0) {
        pSBP[forward.segments,]$left_gpos = pSBP[forward.segments,]$start_spos
        pSBP[forward.segments,]$right_gpos = pSBP[forward.segments,]$end_spos
        pSBP[forward.segments,]$left_rpos = pSBP[forward.segments,]$start_rpos
        pSBP[forward.segments,]$right_rpos = pSBP[forward.segments,]$end_rpos
    }
    if (length(reverse.segments) > 0) {
        pSBP[reverse.segments,]$left_gpos =  pSBP[reverse.segments,]$primary.seq.length - pSBP[reverse.segments,]$end_spos
        pSBP[reverse.segments,]$right_gpos = pSBP[reverse.segments,]$primary.seq.length - pSBP[reverse.segments,]$start_spos
        pSBP[reverse.segments,]$left_rpos = pSBP[reverse.segments,]$end_rpos
        pSBP[reverse.segments,]$right_rpos = pSBP[reverse.segments,]$start_rpos
    }
    return(pSBP)
}


# all rows in contig.pSBP are from same contig
# the aim here is to pair off adjacent rows/segments into segments which are left and right off a breakpoint.
# First, we define "global" sequence positions by doing a reverse complement of sequences which are in direction
# opposite to that of the principal segment  Then, seqments are ordered according to their common (global) sequence
# position.
# The first and last segments have breakpoints only on one side, while middle segments will have breakpoints
# at both ends.  All segments except the first one are marked as right segments of a SBP pair; middle segments
# will later be duplicated to yield the left segment.
mark.segments = function(contig.pSBP) {
    # To each pSBP row assign a breakpoint ID (used to merge), a segment type (first, mid, last), and segment position with respect to BP (left or right)
    # mid segments will be duplicated later.
    # Assign direction depending on whether segment has is_reverse value same or different than primary segment
    num.pSBP = nrow(contig.pSBP)
    # if only one entry here, that means that breakpoint was mapped from only one side.  Discard it.
    if (num.pSBP==1) return(contig.pSBP[NULL,])

    primary.alignment = contig.pSBP[contig.pSBP$is_primary,]
    if (nrow(primary.alignment) == 0) {
        s = paste("Either no primary segments for contig", unique(contig.pSBP$query_name))
        stop(s)
    }
    if (nrow(primary.alignment) > 1) {
        s = paste("Either 2+ primary segments for contig", unique(contig.pSBP$query_name))
        stop(s)
    }

    # importantly, $is_forward refers to whether segment direction is same as that of the primary segment.
    # that is, the primary alignment defines the forward direction.
    contig.pSBP$is_forward = contig.pSBP$is_reverse == primary.alignment$is_reverse

    # we care about primary length sequence for reversing sequence positions
    contig.pSBP$primary.seq.length = primary.alignment$seq_len

    # Define "global" sequence and reference by "flipping" sequences which have different orientation than principal sequence
    contig.pSBP = define.left.right.pos(contig.pSBP)
    # Order the sequences according to their sequence position midpoints
    contig.pSBP = reorder.by.seq(contig.pSBP) 

    # Now define columns which will help combine individual sequences into pairs of left, right sequences whose junction indicates a breakpoint
    contig.pSBP$bp.id = seq(0,num.pSBP-1)
#    contig.pSBP$num.bp = num.pSBP-1   # num.bp is number of breakpoints in this contig (this won't catch one-sided breakpoints...)


    # stuff here deals with expanding mid segments (those with BP on each end) into two pairs
    contig.pSBP$h.pos = rep.int("right", num.pSBP)
    contig.pSBP$seg.type = rep.int("mid", num.pSBP)

    # now take care of first, last entries
    contig.pSBP$bp.id[1] = 1
    contig.pSBP$h.pos[1] = "left"
    contig.pSBP$seg.type[1] = "first"
    contig.pSBP$seg.type[num.pSBP] = "last"

    # "mid" entries are duplicated to be on left in next bp
    pSBP.mid = contig.pSBP[contig.pSBP$seg.type == "mid",]
    if (nrow(pSBP.mid) > 0) {
        pSBP.mid$h.pos = "left"
        pSBP.mid$bp.id = pSBP.mid$bp.id + 1
        contig.pSBP = rbind(contig.pSBP, pSBP.mid)
    }

    return(contig.pSBP)
}


# Merge adjacent pSBP segments into SBP data frame with one breakpoint per row.
# pSBP may have multiple breakpoints per contig; for N pSBP lines from a given contig,
# will create (N-1) breakpoints.
# all pSBP segments (lines) with same contig (qname) have postitions normalized with respect to primary segment.
# They are then sorted by their midpoint sequence position and 
# assigned a seg.type ("first", "mid", "last"), a horizontal position ("left", "right") and 
# a breakpoint number (1..(N-1)).  Entries which are "mid" are duplicated so that they appear once
# as "left" and once as "right" for different breakpoint numbers.  Finally, left and right 
# segments for the same breakpoint ID are merged to create the left and right segments which demarcate
# one breakpoint, which becomes a row in SBP
# we also define left and right sequence and reference positions; they are equivalent to start, end positions in cases
# where contig has same direction as principal segment (is_forward), and the opposite when opposite direction.  See notebook 5/11/15
parse.pSBP = function(pSBP) {
    # ddply splits on unique combinations of listed columns and applies function to each group
    pSBP = ddply(pSBP, "query_name", function(df) return( mark.segments(df) ) )
    if (nrow(pSBP) == 0) {
        cat(paste("No breakpoints.  Quitting.\n"))
        q()
    }

#    # "mid" entries are duplicated to be on left in next bp
#    pSBP.mid = pSBP[pSBP$seg.type == "mid",]
#    if (nrow(pSBP.mid) > 0) {
#        pSBP.mid$h.pos = "left"
#        pSBP.mid$bp.id = pSBP.mid$bp.id + 1
#        pSBP = rbind(pSBP, pSBP.mid)
#    }

#query_name, ref_name, seq_len, start_spos, end_spos, start_rpos, end_rpos, is_reverse is_primary, is_forward, primary.seq.length, left_gpos, right_gpos, left_rpos, right_rpos, mid_gpos, 
#bp.id, h.pos, seg.type


    pSBP = pSBP[, c("query_name", "ref_name", "is_primary", "bp.id", "is_forward", "h.pos", "left_gpos", "right_gpos", "left_rpos", "right_rpos")]

    # now split into left (Sa) and right (Sb) segments, clean up, and merge
    pSBP.Sa = pSBP[pSBP$h.pos=="left",]  
    pSBP.Sb = pSBP[pSBP$h.pos=="right",]   # right segment
    pSBP.Sa$h.pos = NULL
    pSBP.Sb$h.pos = NULL

    SBP = merge(pSBP.Sa, pSBP.Sb, by=c("query_name", "bp.id"), suffixes=c(".Sa", ".Sb"))

    # Add to each SBP line a unique identifier for the query_name - contig.id
    SBP$contig.id = c(as.factor(SBP$query_name))
    keep.first = c("query_name", "contig.id")
    SBP = SBP[,c(keep.first,setdiff(names(SBP),keep.first))]

    return(SBP)
}

options("width"=180) # useful for debugging
#options("width"=270) 
args = parse_args()
pSBP = read.pSBP(args$pSBP.fn)
SBP = parse.pSBP(pSBP)

cat(paste("Writing to", args$SBP.fn, "\n"))
write.table(SBP, file = args$SBP.fn, quote = FALSE, sep = "\t", row.names = FALSE, col.names = TRUE)



